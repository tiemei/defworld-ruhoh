---
title: 并发编程 - 锁
date: '2014-12-18'
description:
categories: 'Concurrent Programming'
---

# 饥饿和公平

饥饿是说某个线程总是被其他线程抢走CPU运行时间，而公平指所有的线程都能公平的获得运行机会。  
如果是使用synchronized同步块，不能保证某个线程一定获得运行机会，所以需要使用锁。锁的实现里可以自己控制唤醒时的机会分配。理论上Java不能实现100%公平。  

# 自旋锁

自旋锁是采用让当前线程不停地在循环体内执行实现的。  

# 阻塞锁

阻塞锁，与自旋锁不同，改变了线程的运行状态。  
阻塞锁的优势在于，阻塞的线程不会占用cpu时间，不会导致。CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。  
理想的情况则是; 在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。

# 可重入锁  

可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，等到其他线程unlock时，这个线程能够从这个锁里出来。    

参考：  

[饥饿和公平](http://ifeve.com/starvation-and-fairness/)  
[java锁的种类以及辨析（一）：自旋锁](http://ifeve.com/java_lock_see1/)  
[Java锁的种类以及辨析（二）：自旋锁的其他种类](http://ifeve.com/java_lock_see2/)    
[Java锁的种类以及辨析（三）：阻塞锁](http://ifeve.com/java_lock_see3/)  
[Java锁的种类以及辨析（四）：可重入锁](http://ifeve.com/java_lock_see4/)  


